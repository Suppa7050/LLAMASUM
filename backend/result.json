{
  "data": "KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n1 \n SOFTWARE ENGINEERING  \nUNIT \u2013 1  \nCHAPTER \u2013 1  \nINTRODUCTION TO SOFTWARE ENGINEERING  \nI. Definition \nSoftware is program/ set of programs containing instructions which provide desired \nfunctionality. Also comprises of data structures that enable the program to manipulate \ninformation  \nEngineering is the process of designing and building something that serves a particular \npurpose  \nSoftware Engineering is a systematic approach to the development, operation and \nmaintenance of desired software  \nII. Evolving Role of Software \nSoftware serves as a:  \n- Product: It delivers the computing potential of a H/W i.e., enables the h/w to deliver \nthe expected functionality . Acts as information transformer  \n- Vehicle to deliver the product: Helps in creation and control of other programs i.e., it \nhelps other software to do functions and helps as platform. E.g., Operating System  \nToday, software takes on a dual role. It is a product and, at the same time, the vehicle for \ndelivering a product. As a product, it delivers the computing potential embodied by computer \nhardware or, more broadly, a network of computers that are accessible by local hardware. \nWhether it resides within a cellular phone or operates inside a mainframe computer, software \nis an information transformer\u2014producing, managing, acquiring, modifying, displaying, or \ntransmitting information that can be as simple as a single bit or as complex as a multimedia \npresentation. As the vehicle used to deliver the product, software acts as the basis for the \ncontrol of the computer (operating systems), the communication of information (networks), \nand the creation and control of other programs (software tools and environments). Software \ndelivers the most important product of our time\u2014information. Software transforms personal \ndata (e.g., an individual\u2019s financial transactions) so that the data can be more useful in a local \ncontext; it manages business information to enhance competitiveness; it provides a gateway KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n2 \n to worldwide information networks (e.g., Internet) and provides the means for acquiring \ninformation in all of its forms. The role of computer software has undergone significant \nchange over a time span of little more than 50 years. Dramatic improvements in hardware \nperformance, profound changes in computing architectures, vast increases in memory and \nstorage capacity, and a wide variety of exotic input and output options have all precipitated \nmore sophisticated and complex computer -based systems. The lone programmer of an earlier \nera has been replaced by a team of software specialists, each focusing on one part of the  \ntechnology required to deliver a complex application.  \nIII. Why Software Engineering is important? \n \ni. Imposes discipline to work that can become quite chaotic - Lot of steps are involved \nin the development of a s/w, so if a systematic approach is not taken, it becomes \ndifficult/clumsy \nii. Ensures high quality of software - If a s/w could deliver the features and \nfunctionalities required then it is a high-quality software. \niii. Enables us to build complex systems in a timely manner - Whenever we have a \nhuge/complex project, then we need to set proper deadlines and milestones of the time taken \nin each step, so that in time we can deliver the s/w to the customer. \n \nIV. Difference between Software and Hardware \nSoftware : \n\u2022 S/W is logical unit  \n\u2022 No spare parts for s/w  \n\u2022 Problem statement may not be complete and clear initially  \n\u2022 Requirements may change with time   \n\u2022 Multiple copies (less cost)  \n\u2022 Idealized and actual graph  \nHardware:  \n\u2022 H/W is physical unit  \n\u2022 Spare parts for h/w exist  KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n3 \n \u2022 Problem statement is clearly mentioned at the beginning of development  \n\u2022 Requirements are fixed before manufacturing  \n\u2022 Multiple copies (more cost)  \n\u2022 Bath tub graph  \nBath Tub Curve:  \n \nFigure 1: Bath tub Curve - Failure curve for Hardware  \n\u2022 Given the name bath tub because its shape is same as bath tub.  \n\u2022 It explains the reliability of the product i.e. until how many days / time the product \nworks  \n\u2022 We have 3 stages in bath tub curve:  \n\u2013 Decreasing failure rate or Infant mortality  \n\u2013 Constant failure rate  \n\u2013 Increasing failure rate or wear out (H/W effected by the environment factors \nlike dust, temperature, pollution, etc). S/W does not have wear out.  \n\u2022 Decreasing failure rate:  \n\u2013 As the product in this stage is new, there are very less chances of it to fail. The \nproduct still fails because of  \n\u2022 Manufacturing defect  \n\u2022 We haven\u2019 t assembled it properly  \nKR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n4 \n \u2022 It is a weak part or product.  \n\u2022 Constant failure rate:  \n\u2013 It is named as constant failure rate because the graph remains in straight line \naccording to the time.  \n\u2013 Most of the products fail in this stage  \n\u2013 It is the service life of the product.  \n\u2022 Increasing failure rate:  \n\u2013 This is the stage where we use the product more than its service period. The \nsuddenly, the product may fail.  \n\u2013 It is named increasing failure rate as the curve moves upwards as shown \naccording to the time.  \n \nFigure 2: Failure rates in Bath tub Curve  \nIdealized Curve:  \n\u2022 Since there is no wear out in s/w the curve must undergo on 2 phases i.e., decreasing \nfailure rate and constant failure rate which is called as Idealized curve.  \n\u2022 But in reality, idealized curve is not possible.  \n\u2022 Initial failure happens just like h/w due to undetected defects.  \nKR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n5 \n \u2022 After correcting the defects, the curve reaches a steady state, but if any change oc curs \nin the s/w then there is spike in the graph.  \n\u2022 Most of the times the failure rate increases when a change effect is requested. The \nactual curve is higher than the idealized curve.  \n \nFigure 3: Idealized Curve - Failure curve for Software  \n \nV. Work Product: \n \nWork product is the result or outcome of Software Engineering  \nThe outcome is in 2 perspectives:  \n1. Software Engineer : The set of programs, the content (data) along with documentation that \nis a part of s/w.  \n2. User/Customer : The functionality delivered by the s/w that improves user experience  \n \nVI. Software Engineering focuses on: \n \n\u2022 Quality (While Software development)  \n\u2013 Functional : To what extent that we have delivered the correct s/w and is it \nreaching the expectations. Degree to which correct software is produced.  \n\u2013 Non functional : Also called structural attributes. Features other than functions \nof s/w like robustness, security, etc.  \n\u2022 Maintainability (After the software has been developed and delivered)  \nKR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n6 \n \u2013 Should be easily enhanced and adapted to changing requirements whenever \nrequired.  \n \nVII. Changing Nature of Software: \n \nThe nature of software has changed a lot over the years.  \n1. System software:  Infrastructure software come under this category like compilers, \noperating systems, editors, drivers, etc. Basically, system software is a collection of \nprograms to provide service to other programs.  \n2. Real time software:  This software is used to monitor, control and analyse real world \nevents as they occur. An example may be software required for weather forecasting. \nSuch software will gather and process the status of temperature, humidity and other \nenvironmental parameters to forecast the weather.  \n3. Embedded software:  This type of software is placed in \u201cRead-Only- Memory \n(ROM) \u201d of the product and control the various functions of the product. The product \ncould be an aircraft, automobile, security system, signalling system, control unit of \npower plants, etc. The embedded software handles hardware components and is also \ntermed as intelligent software.  \n4. Business software:  This is the largest application area. The software designed to \nprocess business applications is called business software. Business software could be \npayroll, file monitoring system, employee management, account management. It may \nalso be a data warehousing tool which helps us to take decisions based on available \ndata. Management information system, enterprise resource planning (ERP) and such \nother software are popular examples of business software.  \n5. Personal computer software:  The software used in personal computers are covered \nin this category. Examples are word processors, computer graphics, multimedia and \nanimating tools, database management, computer games etc. This is a very upcoming \narea and many big organisations are concentrating their effort here due to large \ncustomer base.  \n6. Artificial intelligence software:  Artificial Intelligence software makes use of non-\nnumerical algorithms to solve complex problems that are not amenable to \ncomputation or straight forward analysis. Examples are expert systems, artificial \nneural network, signal processing software etc.  KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n7 \n 7. Web based software:  The software related to web applications come under this \ncategory. Examples are CGI, HTML, Java, Perl, DHTML etc.  \n \nVIII.  Legacy Software: \nLegacy:  \n\u2022 Generally, something which u get in inheritance  \n\u2022 Example: Money / Status  \n\u2022 In terms of s/w, something which is old but still in use and difficult to replace.  \n\u2022 Example: Legacy car  \nLegacy System:  \n\u2022 The combination of legacy software and hardware overall is called legacy system.  \n\u2022 Ex: a s/w working in win XP is not compatible with windows 11.  \nLegacy Software:  \n\u2022 Outdated s/w still in use as it is fulfilling the needs of the organization  \n\u2022 Ex: Bank s/w  \n\u2022 Customize s/w: s/w once developed will not have any changes or new requirements \nthen we use it for decade  \n\u2022 Ex: Games  \nNeed to be replaced for the following reasons:  \nDue to change in business model  \nDue to change in architecture  \nInadequate security, performance, flexibility, etc.  \nIX. Software Myths: \nThe development of software requires dedication and understanding on the developers' part. \nMany software problems arise due to myths that are formed during the initial stages of \nsoftware development. Software myths propagate false beliefs and confusion in the minds of KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n8 \n management, users and developers. Blind belief that management, customers and \npractitioners have on s/w and the process to use it. Managers, who own software development \nresponsibility, are often under strain and pressure to maintain a software budget, time \nconstraints, improved quality, and many other considerations. Common management myths \nare: \n\u2022 Management myths  \n\u2022 Customer myths  \n\u2022 Practitioner\u2019s myths  \ni. Management Myths: \nMyth 1: \nWe have all the standards and procedures available for  software development. \nFact: \n\uf0b7 Software experts do not know all the requirements for t he software development. \n\uf0b7 And all existing processes are incomplete as new soft ware development is based on new \nand different problem. \nMyth 2: \nThe addition of the latest hardware programs will improve  the software development. \nFact: \n\uf0b7 The role of the latest hardware is not very high on standard software development; instead \n(CASE) Engineering tools help the computer, they are more  important than hardware to \nproduce quality and productivity. \n\uf0b7 Hence, the hardware resources are misused. \nMyth 3: \n\uf0b7 With the addition of more people and program planners t o Software development can help \nmeet project deadlines (If lagging behind). \nFact:  \n\uf0b7 If software is late, adding more people will merely ma ke the problem worse. This is \nbecause the people already working on the project n ow need to spend time educating the \nnewcomers, and are thus taken away from their work. The newcomers are also far less \nproductive than the existing software engineers, and s o the work put into training them to \nwork on the software does not immediately meet with an appropriate reduction in work. KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n9 \n  \n \n \nii. Customer Myths:  \nThe customer can be the direct users of the software , the technical team, marketing / sales \ndepartment, or other company. Customer has myths le ading to false expectations \n(customer) & that \u2019s why you create dissatisfaction with the developer. \nMyth 1: \nA general statement of intent is enough to start writing plans (software development) and \ndetails of objectives can be done over time. \nFact: \n\uf0b7 Official and detailed description of the database func tion, ethical performance, \ncommunication, structural issues and the verification pr ocess are important. \n\uf0b7 Unambiguous requirements (usually derived iteratively)  are developed only through \neffective and continuous communication between custome r and developer. \nMyth 2: \nSoftware requirements continually change, but change c an be easily accommodated \nbecause software is flexible \nFact: \n\uf0b7 It is true that software requirements change, but the  impact of change varies with the time \nat which it is introduced. When requirements changes are r equested early (before design or \ncode has been started), the cost impact is relatively  small (Refer Figure 4). However, as \ntime passes, the cost impact grows rapidly \u2014resources have been committed, a design \nframework has been established, and change can cause u pheaval that requires additional \nresources and major design modification. \n \niii. Practitioner \u2019s Myths: \nMyths 1: \nThey believe that their work has been completed with th e writing of the plan. \nFact: \n\uf0b7 It is true that every 60-80% effort goes into the mai ntenance phase (as of the latter software \nrelease). Efforts are required, where the product is available first delivered to customers. KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n10 \n Myths 2: \nThere is no other way to achieve system quality, unt il it is \u201crunning \u201d. \nFact: \n\uf0b7 Systematic review of project technology is the qual ity of effective software verification \nmethod. These updates are quality filters and more ac cessible than test. \nMyth 3: \nAn operating system is the only product that can be su ccessfully exported project. \nFact: \n\uf0b7 A working system is not enough, the right document bro chures and booklets are also \nrequired to provide guidance & software support. \nMyth 4:  \nEngineering software will enable us to build powerful an d unnecessary document & always \ndelay us. \nFact:  \n\uf0b7 Software engineering is not about creating documents. I t is about creating a quality product. \nBetter quality leads to reduced rework. And reduced rework results in faster delivery times. \n \nX. SOFTWARE ENGINEERING - A LAYERED TECHNOLOGY \nIEEE has developed a more comprehensive definition of software engineering:  \n\u201cSoftware engineering is the application of a systematic, disciplined, quantifiable \napproach to the development, operation, and maintenance of software. \u201d \n\uf0b7 Software Engineering is a layered technology.  \nSoftware Engineering encompasses a Process, Methods for managing and engineering \nsoftware and tools .  \nThe following Figure represents Software engineering Layers  \n \nKR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n11 \n Software Engineering \u2013 A Layered Technology  \nReferring to the above Figure, any engineering approach must rest on an organizational \ncommitment to quality . The bedrock that supports software engineering is a quality focus . \nThe foundation for software engineering is the process layer . The software engineering \nprocess is the glue that holds the technology layers together and enables the rational and \ntimely development of computer software. Process defines a framework that must be \nestablished for the effective delivery of software engineering technology.  \nSoftware engineering methods provide the technical how -to for building software. Methods \nencompass a broad array of tasks that include communication, requirements analysis, design \nmodelling, program construction, testing, and support.  Software engineering tools provide \nautomated or semi -automated support for the process and the methods. When tools are \nintegrated so that information created by one tool can be used by another , a system for the \nsupport of software development, called computer -aided software engineering, is \nestablished.  \n \nXI. THE SOFTWARE PROCESS FRAMEWORK \nA process is a collection of activities, actions, and tasks that are performed when some \nwork product is to be created.  \nAn activity strives to achieve a broad objective (e.g., communication with stakeholders) and \nis applied regardless of the application domain, size of the project, complexity of the effort, \nor degree of rigor with which software engineering is to be applied.  \nAn action encompasses a set of tasks that produce a major work product (e.g., an \narchitectural design model).  \nA task focuses on a small, but well -defined objective (e.g., conducting a unit test) that \nproduces a tangible outcome.  \nA process framework establishes the foundation for a complete software engineering process \nby identifying a small number of framework activities that apply  to all software projects, \nregardless of their size or complexity. In addition, the process framework encompasses a set \nof umbrella activities that are applicable across the entire software process.  KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n12 \n  \nA generic process framework for software engineering encompasses five activities:  \n\u25cf Communication  \n\u25cf Planning  \n\u25cf Modelling  \n\u25cf Construction  \n\u25cf Deployment  \nThese five generic framework activities can be used during the development of small, simple \nprograms, the creation of large Web applications, and for the engineering of large, complex \ncomputer -based systems.  \nSoftware engineering process framework activities are complemented by several  Umbrella \nActivities . In general, umbrella activities are applied throughout a software project and help \na software team manage and control progress, quality, change, and risk. Typical umbrella \nactivities include:  \n\u25cf Software project tracking and control  \n\u25cf Risk management  \n\u25cf Software quality assurance  \n\u25cf Technical reviews  \n\u25cf Measurement  \n\u25cf Software configuration management  \n\u25cf Reusability management  \n\u25cf Work product preparation and production  \n \n KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n13 \n  \n \nXII. A GENERIC PROCESS MODEL \n \n \nThe software process is represented schematically in the following figure. Each framework \nactivity is populated by a set of software engineering actions. Each software engineerin g \naction is defined by a task set that identifies the work tasks that are to be completed, the work \nproducts that will be produced, the quality assurance points that will be required, and the \nmilestones that will be used to indicate progress. \nA generic process framework defines five framework activities \u2014communication, planning, \nmodeling, construction, and deployment. In addition, a set of umbrella activities like project \ntracking and control, risk management, quality assurance, configuration management, \ntechnical reviews, and others are applied throughout the process. \nKR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n14 \n \nThis aspect is called process flow. It describes how the framework activities and the actions \nand tasks that occur within each framework activity are organized concerning sequence and \ntime and is illustrated in the following figure \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nA generic process framework for software engineering A linear process flow executes each \nof the five framework activities in sequence. An iterative process flow repeats one or more of \nthe activities before proceeding to the next. An evolutionary process flow executes the \nactivities in a \u201ccircular \u201d manner.  A parallel process flow executes one or more activities in \nparallel with other activities. \n \n KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n15 \n  \n \n",
  "summary": "KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n1 \n SOFTWARE ENGINEERING  \nUNIT \u2013 1  \nCHAPTER \u2013 1  \nINTRODUCTION TO SOFTWARE ENGINEERING  \nI. Definition \nSoftware is program/ set of programs containing instructions which provide desired \nfunctionality. Also comprises of data structures that enable the program to manipulate \ninformation  \nEngineering is the process of designing and building something that serves a particular \npurpose  \nSoftware Engineering is a systematic approach to the development, operation and \nmaintenance of desired software  \nII. Evolving Role of Software \nSoftware serves as a:  \n- Product: It delivers the computing potential of a H/W i.e., enables the h/w to deliver \nthe expected functionality . Acts as information transformer  \n- Vehicle to deliver the product: Helps in creation and control of other programs i.e., it \nhelps other software to do functions and helps as platform. E.g., Operating System  \nToday, software takes on a dual role. It is a product and, at the same time, the vehicle for \ndelivering a product. As a product, it delivers the computing potential embodied by computer \nhardware or, more broadly, a network of computers that are accessible by local hardware. \nWhether it resides within a cellular phone or operates inside a mainframe computer, software \nis an information transformer\u2014producing, managing, acquiring, modifying, displaying, or \ntransmitting information that can be as simple as a single bit or as complex as a multimedia \npresentation. As the vehicle used to deliver the product, software acts as the basis for the \ncontrol of the computer (operating systems), the communication of information (networks), \nand the creation and control of other programs (software tools and environments). Software \ndelivers the most important product of our time\u2014information. Software transforms personal \ndata (e.g., an individual\u2019s financial transactions) so that the data can be more useful in a local \ncontext; it manages business information to enhance competitiveness; it provides a gateway KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n2 \n to worldwide information networks (e.g., Internet) and provides the means for acquiring \ninformation in all of its forms. The role of computer software has undergone significant \nchange over a time span of little more than 50 years. Dramatic improvements in hardware \nperformance, profound changes in computing architectures, vast increases in memory and \nstorage capacity, and a wide variety of exotic input and output options have all precipitated \nmore sophisticated and complex computer -based systems. The lone programmer of an earlier \nera has been replaced by a team of software specialists, each focusing on one part of the  \ntechnology required to deliver a complex application.  \nIII. Why Software Engineering is important? \n \ni. Imposes discipline to work that can become quite chaotic - Lot of steps are involved \nin the development of a s/w, so if a systematic approach is not taken, it becomes \ndifficult/clumsy \nii. Ensures high quality of software - If a s/w could deliver the features and \nfunctionalities required then it is a high-quality software. \niii. Enables us to build complex systems in a timely manner - Whenever we have a \nhuge/complex project, then we need to set proper deadlines and milestones of the time taken \nin each step, so that in time we can deliver the s/w to the customer. \n \nIV. Difference between Software and Hardware \nSoftware : \n\u2022 S/W is logical unit  \n\u2022 No spare parts for s/w  \n\u2022 Problem statement may not be complete and clear initially  \n\u2022 Requirements may change with time   \n\u2022 Multiple copies (less cost)  \n\u2022 Idealized and actual graph  \nHardware:  \n\u2022 H/W is physical unit  \n\u2022 Spare parts for h/w exist  KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n3 \n \u2022 Problem statement is clearly mentioned at the beginning of development  \n\u2022 Requirements are fixed before manufacturing  \n\u2022 Multiple copies (more cost)  \n\u2022 Bath tub graph  \nBath Tub Curve:  \n \nFigure 1: Bath tub Curve - Failure curve for Hardware  \n\u2022 Given the name bath tub because its shape is same as bath tub.  \n\u2022 It explains the reliability of the product i.e. until how many days / time the product \nworks  \n\u2022 We have 3 stages in bath tub curve:  \n\u2013 Decreasing failure rate or Infant mortality  \n\u2013 Constant failure rate  \n\u2013 Increasing failure rate or wear out (H/W effected by the environment factors \nlike dust, temperature, pollution, etc). S/W does not have wear out.  \n\u2022 Decreasing failure rate:  \n\u2013 As the product in this stage is new, there are very less chances of it to fail. The \nproduct still fails because of  \n\u2022 Manufacturing defect  \n\u2022 We haven\u2019 t assembled it properly  \nKR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n4 \n \u2022 It is a weak part or product.  \n\u2022 Constant failure rate:  \n\u2013 It is named as constant failure rate because the graph remains in straight line \naccording to the time.  \n\u2013 Most of the products fail in this stage  \n\u2013 It is the service life of the product.  \n\u2022 Increasing failure rate:  \n\u2013 This is the stage where we use the product more than its service period. The \nsuddenly, the product may fail.  \n\u2013 It is named increasing failure rate as the curve moves upwards as shown \naccording to the time.  \n \nFigure 2: Failure rates in Bath tub Curve  \nIdealized Curve:  \n\u2022 Since there is no wear out in s/w the curve must undergo on 2 phases i.e., decreasing \nfailure rate and constant failure rate which is called as Idealized curve.  \n\u2022 But in reality, idealized curve is not possible.  \n\u2022 Initial failure happens just like h/w due to undetected defects.  \nKR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n5 \n \u2022 After correcting the defects, the curve reaches a steady state, but if any change oc curs \nin the s/w then there is spike in the graph.  \n\u2022 Most of the times the failure rate increases when a change effect is requested. The \nactual curve is higher than the idealized curve.  \n \nFigure 3: Idealized Curve - Failure curve for Software  \n \nV. Work Product: \n \nWork product is the result or outcome of Software Engineering  \nThe outcome is in 2 perspectives:  \n1. Software Engineer : The set of programs, the content (data) along with documentation that \nis a part of s/w.  \n2. User/Customer : The functionality delivered by the s/w that improves user experience  \n \nVI. Software Engineering focuses on: \n \n\u2022 Quality (While Software development)  \n\u2013 Functional : To what extent that we have delivered the correct s/w and is it \nreaching the expectations. Degree to which correct software is produced.  \n\u2013 Non functional : Also called structural attributes. Features other than functions \nof s/w like robustness, security, etc.  \n\u2022 Maintainability (After the software has been developed and delivered)  \nKR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n6 \n \u2013 Should be easily enhanced and adapted to changing requirements whenever \nrequired.  \n \nVII. Changing Nature of Software: \n \nThe nature of software has changed a lot over the years.  \n1. System software:  Infrastructure software come under this category like compilers, \noperating systems, editors, drivers, etc. Basically, system software is a collection of \nprograms to provide service to other programs.  \n2. Real time software:  This software is used to monitor, control and analyse real world \nevents as they occur. An example may be software required for weather forecasting. \nSuch software will gather and process the status of temperature, humidity and other \nenvironmental parameters to forecast the weather.  \n3. Embedded software:  This type of software is placed in \u201cRead-Only- Memory \n(ROM) \u201d of the product and control the various functions of the product. The product \ncould be an aircraft, automobile, security system, signalling system, control unit of \npower plants, etc. The embedded software handles hardware components and is also \ntermed as intelligent software.  \n4. Business software:  This is the largest application area. The software designed to \nprocess business applications is called business software. Business software could be \npayroll, file monitoring system, employee management, account management. It may \nalso be a data warehousing tool which helps us to take decisions based on available \ndata. Management information system, enterprise resource planning (ERP) and such \nother software are popular examples of business software.  \n5. Personal computer software:  The software used in personal computers are covered \nin this category. Examples are word processors, computer graphics, multimedia and \nanimating tools, database management, computer games etc. This is a very upcoming \narea and many big organisations are concentrating their effort here due to large \ncustomer base.  \n6. Artificial intelligence software:  Artificial Intelligence software makes use of non-\nnumerical algorithms to solve complex problems that are not amenable to \ncomputation or straight forward analysis. Examples are expert systems, artificial \nneural network, signal processing software etc.  KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n7 \n 7. Web based software:  The software related to web applications come under this \ncategory. Examples are CGI, HTML, Java, Perl, DHTML etc.  \n \nVIII.  Legacy Software: \nLegacy:  \n\u2022 Generally, something which u get in inheritance  \n\u2022 Example: Money / Status  \n\u2022 In terms of s/w, something which is old but still in use and difficult to replace.  \n\u2022 Example: Legacy car  \nLegacy System:  \n\u2022 The combination of legacy software and hardware overall is called legacy system.  \n\u2022 Ex: a s/w working in win XP is not compatible with windows 11.  \nLegacy Software:  \n\u2022 Outdated s/w still in use as it is fulfilling the needs of the organization  \n\u2022 Ex: Bank s/w  \n\u2022 Customize s/w: s/w once developed will not have any changes or new requirements \nthen we use it for decade  \n\u2022 Ex: Games  \nNeed to be replaced for the following reasons:  \nDue to change in business model  \nDue to change in architecture  \nInadequate security, performance, flexibility, etc.  \nIX. Software Myths: \nThe development of software requires dedication and understanding on the developers' part. \nMany software problems arise due to myths that are formed during the initial stages of \nsoftware development. Software myths propagate false beliefs and confusion in the minds of KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n8 \n management, users and developers. Blind belief that management, customers and \npractitioners have on s/w and the process to use it. Managers, who own software development \nresponsibility, are often under strain and pressure to maintain a software budget, time \nconstraints, improved quality, and many other considerations. Common management myths \nare: \n\u2022 Management myths  \n\u2022 Customer myths  \n\u2022 Practitioner\u2019s myths  \ni. Management Myths: \nMyth 1: \nWe have all the standards and procedures available for  software development. \nFact: \n\uf0b7 Software experts do not know all the requirements for t he software development. \n\uf0b7 And all existing processes are incomplete as new soft ware development is based on new \nand different problem. \nMyth 2: \nThe addition of the latest hardware programs will improve  the software development. \nFact: \n\uf0b7 The role of the latest hardware is not very high on standard software development; instead \n(CASE) Engineering tools help the computer, they are more  important than hardware to \nproduce quality and productivity. \n\uf0b7 Hence, the hardware resources are misused. \nMyth 3: \n\uf0b7 With the addition of more people and program planners t o Software development can help \nmeet project deadlines (If lagging behind). \nFact:  \n\uf0b7 If software is late, adding more people will merely ma ke the problem worse. This is \nbecause the people already working on the project n ow need to spend time educating the \nnewcomers, and are thus taken away from their work. The newcomers are also far less \nproductive than the existing software engineers, and s o the work put into training them to \nwork on the software does not immediately meet with an appropriate reduction in work. KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n9 \n  \n \n \nii. Customer Myths:  \nThe customer can be the direct users of the software , the technical team, marketing / sales \ndepartment, or other company. Customer has myths le ading to false expectations \n(customer) & that \u2019s why you create dissatisfaction with the developer. \nMyth 1: \nA general statement of intent is enough to start writing plans (software development) and \ndetails of objectives can be done over time. \nFact: \n\uf0b7 Official and detailed description of the database func tion, ethical performance, \ncommunication, structural issues and the verification pr ocess are important. \n\uf0b7 Unambiguous requirements (usually derived iteratively)  are developed only through \neffective and continuous communication between custome r and developer. \nMyth 2: \nSoftware requirements continually change, but change c an be easily accommodated \nbecause software is flexible \nFact: \n\uf0b7 It is true that software requirements change, but the  impact of change varies with the time \nat which it is introduced. When requirements changes are r equested early (before design or \ncode has been started), the cost impact is relatively  small (Refer Figure 4). However, as \ntime passes, the cost impact grows rapidly \u2014resources have been committed, a design \nframework has been established, and change can cause u pheaval that requires additional \nresources and major design modification. \n \niii. Practitioner \u2019s Myths: \nMyths 1: \nThey believe that their work has been completed with th e writing of the plan. \nFact: \n\uf0b7 It is true that every 60-80% effort goes into the mai ntenance phase (as of the latter software \nrelease). Efforts are required, where the product is available first delivered to customers. KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n10 \n Myths 2: \nThere is no other way to achieve system quality, unt il it is \u201crunning \u201d. \nFact: \n\uf0b7 Systematic review of project technology is the qual ity of effective software verification \nmethod. These updates are quality filters and more ac cessible than test. \nMyth 3: \nAn operating system is the only product that can be su ccessfully exported project. \nFact: \n\uf0b7 A working system is not enough, the right document bro chures and booklets are also \nrequired to provide guidance & software support. \nMyth 4:  \nEngineering software will enable us to build powerful an d unnecessary document & always \ndelay us. \nFact:  \n\uf0b7 Software engineering is not about creating documents. I t is about creating a quality product. \nBetter quality leads to reduced rework. And reduced rework results in faster delivery times. \n \nX. SOFTWARE ENGINEERING - A LAYERED TECHNOLOGY \nIEEE has developed a more comprehensive definition of software engineering:  \n\u201cSoftware engineering is the application of a systematic, disciplined, quantifiable \napproach to the development, operation, and maintenance of software. \u201d \n\uf0b7 Software Engineering is a layered technology.  \nSoftware Engineering encompasses a Process, Methods for managing and engineering \nsoftware and tools .  \nThe following Figure represents Software engineering Layers  \n \nKR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n11 \n Software Engineering \u2013 A Layered Technology  \nReferring to the above Figure, any engineering approach must rest on an organizational \ncommitment to quality . The bedrock that supports software engineering is a quality focus . \nThe foundation for software engineering is the process layer . The software engineering \nprocess is the glue that holds the technology layers together and enables the rational and \ntimely development of computer software. Process defines a framework that must be \nestablished for the effective delivery of software engineering technology.  \nSoftware engineering methods provide the technical how -to for building software. Methods \nencompass a broad array of tasks that include communication, requirements analysis, design \nmodelling, program construction, testing, and support.  Software engineering tools provide \nautomated or semi -automated support for the process and the methods. When tools are \nintegrated so that information created by one tool can be used by another , a system for the \nsupport of software development, called computer -aided software engineering, is \nestablished.  \n \nXI. THE SOFTWARE PROCESS FRAMEWORK \nA process is a collection of activities, actions, and tasks that are performed when some \nwork product is to be created.  \nAn activity strives to achieve a broad objective (e.g., communication with stakeholders) and \nis applied regardless of the application domain, size of the project, complexity of the effort, \nor degree of rigor with which software engineering is to be applied.  \nAn action encompasses a set of tasks that produce a major work product (e.g., an \narchitectural design model).  \nA task focuses on a small, but well -defined objective (e.g., conducting a unit test) that \nproduces a tangible outcome.  \nA process framework establishes the foundation for a complete software engineering process \nby identifying a small number of framework activities that apply  to all software projects, \nregardless of their size or complexity. In addition, the process framework encompasses a set \nof umbrella activities that are applicable across the entire software process.  KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n12 \n  \nA generic process framework for software engineering encompasses five activities:  \n\u25cf Communication  \n\u25cf Planning  \n\u25cf Modelling  \n\u25cf Construction  \n\u25cf Deployment  \nThese five generic framework activities can be used during the development of small, simple \nprograms, the creation of large Web applications, and for the engineering of large, complex \ncomputer -based systems.  \nSoftware engineering process framework activities are complemented by several  Umbrella \nActivities . In general, umbrella activities are applied throughout a software project and help \na software team manage and control progress, quality, change, and risk. Typical umbrella \nactivities include:  \n\u25cf Software project tracking and control  \n\u25cf Risk management  \n\u25cf Software quality assurance  \n\u25cf Technical reviews  \n\u25cf Measurement  \n\u25cf Software configuration management  \n\u25cf Reusability management  \n\u25cf Work product preparation and production  \n \n KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n13 \n  \n \nXII. A GENERIC PROCESS MODEL \n \n \nThe software process is represented schematically in the following figure. Each framework \nactivity is populated by a set of software engineering actions. Each software engineerin g \naction is defined by a task set that identifies the work tasks that are to be completed, the work \nproducts that will be produced, the quality assurance points that will be required, and the \nmilestones that will be used to indicate progress. \nA generic process framework defines five framework activities \u2014communication, planning, \nmodeling, construction, and deployment. In addition, a set of umbrella activities like project \ntracking and control, risk management, quality assurance, configuration management, \ntechnical reviews, and others are applied throughout the process. \nKR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n14 \n \nThis aspect is called process flow. It describes how the framework activities and the actions \nand tasks that occur within each framework activity are organized concerning sequence and \ntime and is illustrated in the following figure \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nA generic process framework for software engineering A linear process flow executes each \nof the five framework activities in sequence. An iterative process flow repeats one or more of \nthe activities before proceeding to the next. An evolutionary process flow executes the \nactivities in a \u201ccircular \u201d manner.  A parallel process flow executes one or more activities in \nparallel with other activities. \n \n KR21  SOFTWARE ENGINEERING  CSE/IT/CSM/CSD III/I  \n15 \n  \n \n"
}